# Obligatorisk oppgave 2 i Algoritmer og Datastrukturer

Denne oppgaven er en innlevering i Algoritmer og Datastrukturer. 
Oppgaven er levert av følgende studenter:
* Håkon Havn, s344194, s344194@oslomet.no

# Arbeidsfordeling

I oppgaven har vi hatt følgende arbeidsfordeling:
* Håkon Havn har hatt ansvar for oppgavene 1, 2, 3, 4, 5, 6 og 8

# Oppgavebeskrivelse

Oppgave 1 antall() har jeg laget ved å telle hver node i listen med en while løkke der kriteriet er at noden jeg teller opp ikke er null. Dersom en node er null vet jeg at jeg har kommet til enden av listen og jeg returnerer antall noder jeg telte opp.
Metoden tom er mye enklere, og jeg sjekker bare om hode er lik null. Hvis det er det vet jeg at listen er tom, og hvis ikke vet jeg at det hvertfall er en node i listen (og at den da ikke er tom).
Konstruktøren til listen virker ved å først sjekke om arrayet a er tomt, og hvis det er det returneres en feilmelding. Hvis det ikke er tomt så er det en for løkke som itererer gjennom alle elementene i arrayet. For hver iterasjon blir det sjekket om elementet er null. Hvis det er det går løkken videre til neste element, men hvis det ikke er null så blir verdien på denne posisjonen gjort om til en node. Deretter sjekker jeg om tom() er sann (som betyr at verdien jeg legger inn er den første, som da blir til hode). Da skriver jeg at hode og hale er lik noden. Men for alle senere iterasjoner vil ikke tom lenger returnere sant. Herfra er det bare å skrive at den forrige noden sin neste peker, peker på den nåværende noden, og at forrige pekeren peker på den forrige noden. Så oppdaterer man halen slik at den alltid er sist i listen.

I oppgave 2 a) toString() har jeg gjort det lett ved å bruke en StringBuilder. Da trenger jeg bare starte med "[" og dermed verdien til nodene (som jeg går gjennom ved hjelp av en while løkke (sjekker bare at noden ikke er null). Og så sjekker jeg at den neste noden ikke er null, og hvis den ikke er det legger jeg til ett komma og mellomrom. Når løkken er ferdig legger jeg til "]" for å slutte Stringen, så returnerer jeg dette. Det vil gi en utskrift som "[1, 2, 3, 4, 5]".
I omvendtString() gjør jeg akkurat det samme som i toString, med unntaket av at jeg begynner ved halen og bruker forrige pekere istedenfor neste pekere. Her tullet jeg til første gangen med leggInn() metoden, som ikke satte forrige pekerene riktig som gjorde at den hoppet over noen noder, men dette er fikset.
I oppgave 2 b) antok jeg at siden det ikke blir angitt en posisjon, så vil verdien legges til i slutten av listen. Først sjekker jeg om verdien er null. Deretter sjekker jeg om listen er tom ved hjelp av tom(). Hvis den er det så blir hode og hale lik verdi (som er gjort om til en node). Men hvis listen ikke er tom så blir hale sin neste peker lik verdi sin node, og verdi sin node sin forrige peker blir satt til å peke på hale noden. Derretter oppdaterer jeg verdi sin node slik at den blir halen.

I oppgave 3 a) klarer jeg ikke finnNode metoden til å bruke kortere tid. I testen står det at den burde bruke under 20 millisekunder, men jeg har ikke klart å få den under 1000ms enda. Hent() metoden er derimot veldig lett ved å bare bruke indeksKontroll metoden, og dermed finnNode.verdi, som vil returnere verdien til noden vi skal hente. Oppdater() virker ved å først sjekke indeksen vi skal oppdatere, og dermed sjekker den om verdien vi vil oppdatere med er null (hvis den er det sendes det en feilmelding, og hvis ikke går den videre). Siden vi skal oppdatere en verdi, og returnere den gamle verdien betyr det at jeg må lagre den gamle verdien, og dette gjør jeg i en variabel som kalles gammelVerdi. Den bruker bare hent() metoden på indeksen. Deretter bruker jeg finnNode() metoden og endrer verdien til den til den nye verdien. Så øker jeg endringer med 1 og så returnerer jeg den gamle verdien til slutt.
I oppgave 3 b) skulle vi lage en subliste metode. Det gjør jeg ved å sjekke parameterene med fraTilKontroll(), og så lage en ny dobbelt lenket liste som jeg kaller output (siden det er det jeg skal returnere på slutten). Deretter bruker jeg en for løkke som gjør gjennom alle indeksene fra "fra" til "til". Jeg legger inn verdiene ved hjelp av leggInn(hent(i)), som vil hente verdien til den gitte posisjonen, og så legge den inn i output listen. Så returnerer jeg bare output.

I oppgave 4 sin indeksTil metode bruker jeg bare en while løkke der jeg har definert en pos variabel (for posisjon), og denne vil øke for hver iterasjon. I while løkken sjekker jeg om verdien til noden jeg er på, er lik verdien som er gitt i metoden ved hjelp av .equals(). Hvis de er like så returnerer jeg pos variabelen, og hvis ikke går jeg videre til neste node, helt til noden er lik null da while løkken slutter. Hivs while løkken slutter betyr det at verdien ikke finnes i listen, og jeg returnerer da -1.
Inneholder() metoden virker ved hjelp av indeksTil(). Jeg spør bare om indeksTil(verdi) er ulik -1. Hvis den er det returnerer jeg true, siden verdien da finnes. Men hvis den er -1 finnes ikke verdien, og jeg returnerer da false.

I oppgave 5 sin leggInn() metode tas det inn to parametere, indeks og verdi. Det aller første jeg gjør er å sjekke at indeks og verdi er gyldige. Det er 4 ting man må ta hensyn til når man skal kunne sette inn en verdi hvor som helt i tabellen. Er tabellen tom, skal du sette inn i hode noden, i hale noden, eller skal du sette inn i midten av listen. For dette har jeg brukt if setninger. Først sjekker jeg om tom() returnerer sant, og hvis den gjør det setter jeg hode og hale noden til å være lik verdi noden. Hvis listen ikke er tom sjekker jeg om indeks er lik 0 som betyr at jeg skal sette inn foran hode noden, og endre hode noden slik at den er først. Dette gjør jeg ved å skrive at hode noden sin forrige peker peker på verdi noden, og at verdi noden sin neste peker peker på hode noden. Og dermed at hode = verdi noden slik at hode er den første noden i listen. Hvis listen ikke er tom og indeks ikke er 0, sjekker jeg om indeks er lik antall som betyr at jeg skal sette inn bak hale noden. Det virker likt som om jeg skal sette inn foran hode noden. Jeg skriver at verdi noden sin forrige peker peker på hale noden, og at hale noden sin neste peker peker på verdi noden. Deretter oppdaterer jeg hale noden slik at den blir den siste. Til slutt må jeg gjøre slik at jeg kan legge til en node på hvilke som helst andre steder i listen. Dette gjør jeg med en for løkke, som vil iterere gjennom alle nodene helt til "i" i løkken er lik indeksen, som betyr at jeg nå er på plassen jeg vil sette noden inn i. Da må jeg skyve allene nodene bak dette punktet ett hakk bakover for å gjøre plass for den nye noden. Det betyr at den forrige noden sin neste peker, og den neste noden sin forrige peker, må peke på verdi noden. Og så må verdi noden også peke på de to andre nodene. Her gjorde jeg det feil først gangenen fordi jeg glemte å endre den neste noden sin forrige peker. Så jeg kunne gå fra hode til hale helt fint, men når jeg skulle gå fra hale til hode så hoppet den over den nye noden fordi ingen forrige pekere peket på denne noden (f.eks [4, 5, 6, 7] og [7, 6, 4], 5 ble hoppet over fordi 6 peket fortsatt på 4).

I oppgave 6 skulle jeg lage noen fjern metoder. Den ene skal returnere verdien til noden som ble fjernet, og tar inn indeks som posisjon, mens den andre skal returnere sant eller usant, og tar inn en verdi. Metoden som skal returnere noden til slutt laget jeg ved å lagre finnNode(indeks) i en temp node variabel (temp for temporary). Jeg lagret også verdien til denne noden i en "ut" variabel siden denne skal returneres til slutt. Det er tre ting jeg må passe på når jeg skal fjerne en node. Er det hode eller hale noden, eller er det en node midt i listen. Hvis det er hode noden, må jeg passe på at noden etter hode sin forrige peker peker til null, og så blir den noden den nye hode noden. Hvis det er hale noden jeg skal fjerne gjør jeg circa det samme. Noden før hale noden sin neste peker blir satt til null, så blir denne noden den nye hale noden. Og det siste scenarioet er hvis noden er midt i listen. Da skriver jeg bare at den forrige noden sin neste peker, peker på noden etter den nåværende noden. Og at den neste noden sin forrige peker, peker på noden før den nåværende noden. Det betyr at de to nodene ved siden av "temp" noden vil peke på hverandre, og dermer "hoppe over" temp noden. Og til slutt returnerer jeg "ut" variabelen som har verdien til noden som ble fjernet. Den andre metoden som skal returnere sant eller usant laget jeg ved hjelp av den jeg akkurat laget. Jeg ville prøve meg på ternary if noe som jeg fikk til, men tar litt lenger tid nå enn det gjorde. Siden denne metoden tar inn en verdi, så bruker jeg indeksTil(verdi) metoden til å finne verdien. Og dermed kommer en ternary if setning som først sjekker om indeksen er -1, og hvis den er det returneres false, men hvis ikke går  den videre til fjern(indeks) som vil returnere en verdi. Så sjekker jeg om verdien er null eller ikke. Hvis den ikke er null returneres true (siden verdien finnes, og har derfor blitt fjernet), men hvis den er null så returneres false. Setningen ser slik ut
        return indeks == -1 ? false : fjern(indeks) != null ? true : false;

I oppgave 8 a) sjekkes først om iteratorendringer er ulik endringer og hvis det er det sendes en feilmelding. Dermed sjekkes det om det er flere igjen i listen (ved hjelp av hasNext(). Hvis hasNext() er false så sendes også en feilmelding og ingenting gjøres. Men hvis begge if setningene ikke gjør noe (endringer er like og det er flere noder igjen i listen), settes fjernOK til true, så lagrer jeg verdien til den nåværende noden, så går jeg videre til neste node etter å returnere verdien jeg lagret.
Oppgave 8 b) løses veldig enkelt ved å lage en ny iterator av typen DobbeltLenketListeIterator() og så returneres denne.
Oppgave 8 c) løses ved å først bruke indeksKontroll(indeks, false) for å sjekke at indeksen er gyldig. Dersom den er det bruker jeg finnNode(indeks) og lagrer denne noden som "denne". Så settes fjernOK til false, og iteratorendringer til endringer.
Oppgave 8 d) Denne er veldig lik som oppgave c, med unntak av at jeg skriver DobbeltLenketListeIterator(indeks) (med indeks som parameter, istedenfor uten noe). Fordi konstruktøren i klassen bruker indeksKontroll, har jeg ikke trengt å bruke den igjen i denne metoden.
